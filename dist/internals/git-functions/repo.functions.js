"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.repoCommitsByMonthRecords = exports.fillMissingMonths = exports.groupRepoCommitsByMonth = exports.newRepoCompact = exports.cloneRepo = void 0;
const rxjs_1 = require("rxjs");
const execute_command_1 = require("../execute-command/execute-command");
const commit_functions_1 = require("./commit.functions");
// cloneRepo clones a repo from a given url to a given path and returns the path of the cloned repo
function cloneRepo(url, repoPath, repoName) {
    if (!url)
        throw new Error(`url is mandatory`);
    if (!repoPath)
        throw new Error(`Path is mandatory`);
    const command = `git clone ${url} ${repoPath.replaceAll(' ', '_')}`;
    return (0, execute_command_1.executeCommandObs)(`Clone ${repoName}`, command).pipe((0, rxjs_1.tap)(() => `${repoName} cloned`), (0, rxjs_1.map)(() => repoPath), (0, rxjs_1.catchError)((err) => {
        console.error(`!!!!!!!!!!!!!!! Error: while cloning repo "${repoName}" - error code: ${err.code}`);
        console.error(`!!!!!!!!!!!!!!! Command erroring: "${command}"`);
        return rxjs_1.EMPTY;
    }));
}
exports.cloneRepo = cloneRepo;
// newRepoCompact returns an Observable that notifies a new RepoCompact filled with its commits sorted by date ascending
function newRepoCompact(repoPath) {
    return (0, commit_functions_1.fetchCommits)(repoPath).pipe((0, rxjs_1.toArray)(), (0, rxjs_1.map)((commits) => {
        const commitsSorted = commits.sort((a, b) => a.date.getTime() - b.date.getTime());
        const _commitsByMonth = (0, commit_functions_1.commitsByMonth)(commitsSorted);
        const repo = { path: repoPath, commits: commitsSorted, commitsByMonth: _commitsByMonth };
        return repo;
    }), (0, rxjs_1.catchError)((err) => {
        console.error(`Error: while reading the commits of repo "${repoPath}" - error:\n ${JSON.stringify(err, null, 2)}`);
        return rxjs_1.EMPTY;
    }));
}
exports.newRepoCompact = newRepoCompact;
// groupRepoCommitsByMonth retuns all the repos that have commits in a given month grouped by month
// #copilot - the entire method has been generated by copilot once I have specified the return type
function groupRepoCommitsByMonth(repos) {
    const reposByMonthUnordered = repos.reduce((acc, repo) => {
        Object.keys(repo.commitsByMonth).forEach((yearMonth) => {
            if (!acc[yearMonth]) {
                acc[yearMonth] = [];
            }
            acc[yearMonth].push({
                repoPath: repo.path,
                commits: repo.commitsByMonth[yearMonth].commits,
                authors: Array.from(repo.commitsByMonth[yearMonth].authors)
            });
        });
        return acc;
    }, {});
    const reposByMonthOrdered = Object.keys(reposByMonthUnordered).sort().reduce((obj, key) => {
        obj[key] = reposByMonthUnordered[key];
        return obj;
    }, {});
    const [firstYearMonth, lastYearMonth] = getMinMax(Object.keys(reposByMonthOrdered));
    fillMissingMonths(reposByMonthOrdered, firstYearMonth, lastYearMonth, []);
    return reposByMonthOrdered;
}
exports.groupRepoCommitsByMonth = groupRepoCommitsByMonth;
// fillMissingMonths fills the missing months in a given ReposWithCommitsByMonths object
// #copilot - the core of the method has been generated by copilot
function fillMissingMonths(dict, firstYearMonth, lastYearMonth, value) {
    const firstYear = parseInt(firstYearMonth.split('-')[0]);
    const firstMonth = parseInt(firstYearMonth.split('-')[1]);
    const firstYearMonthAsNumber = yearMonthAsNumber(firstYear, firstMonth);
    const lastYear = parseInt(lastYearMonth.split('-')[0]);
    const lastMonth = parseInt(lastYearMonth.split('-')[1]);
    const lastYearMonthAsNumber = yearMonthAsNumber(lastYear, lastMonth);
    for (let year = firstYear; year <= lastYear; year++) {
        for (let month = 1; month <= 12; month++) {
            const yearMonth = `${year}-${month.toString().padStart(2, '0')}`;
            if (!dict[yearMonth]) {
                if (yearMonthAsNumber(year, month) < firstYearMonthAsNumber)
                    continue;
                if (yearMonthAsNumber(year, month) > lastYearMonthAsNumber)
                    continue;
                dict[yearMonth] = value;
            }
        }
    }
}
exports.fillMissingMonths = fillMissingMonths;
function getMinMax(arr) {
    if (!arr || arr.length === 0) {
        throw new Error(`arr must be not null and must have at least one element`);
    }
    var minV = arr[0];
    var maxV = arr[0];
    for (let a of arr) {
        if (a < minV)
            minV = a;
        if (a > maxV)
            maxV = a;
    }
    return [minV, maxV];
}
function yearMonthAsNumber(year, month) {
    return year * 100 + month;
}
// repoCommitsByMonthRecords returns a dictionary where the repo paths are the keys and the values are the commits grouped by month
function repoCommitsByMonthRecords(reposByMonths) {
    const records = {};
    const allYearMonths = Object.keys(reposByMonths).reduce((acc, yearMonth) => {
        acc[yearMonth] = 0;
        return acc;
    }, {});
    const allReposPaths = Object.values(reposByMonths).reduce((acc, repos) => {
        repos.forEach((repo) => {
            if (!acc.includes(repo.repoPath)) {
                acc.push(repo.repoPath);
            }
        });
        return acc;
    }, []);
    allReposPaths.forEach((repoPath) => {
        records[repoPath] = Object.assign({}, allYearMonths);
    });
    Object.entries(reposByMonths).forEach(([yearMonth, repos]) => {
        repos.forEach((repo) => {
            const rec = records[repo.repoPath];
            rec[yearMonth] = repo.commits.length;
        });
    });
    return Object.entries(records).map(([repoPath, commitsByMonth]) => {
        return Object.assign({ repoPath }, commitsByMonth);
    });
}
exports.repoCommitsByMonthRecords = repoCommitsByMonthRecords;
//# sourceMappingURL=repo.functions.js.map