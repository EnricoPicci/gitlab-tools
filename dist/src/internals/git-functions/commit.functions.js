"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.newCommitsByMonth = exports.buildCommitPairArray = exports.newCommitCompact = exports.fetchCommits = void 0;
var rxjs_1 = require("rxjs");
var execute_command_1 = require("../execute-command/execute-command");
// fetchCommit is a function that fetched all the commits from a git repo and returns the sha of each commit and its date
// #copilot comment - the following comment has been added by copilot
// It uses the git log command to fetch the commits
// It returns an observable of an array of strings
// Each string is a commit sha and date separated by a comma
// The observable is an error if the command fails
function fetchCommits(repoPath, fromDate, toDate) {
    if (fromDate === void 0) { fromDate = new Date(0); }
    if (toDate === void 0) { toDate = new Date(Date.now()); }
    if (!repoPath)
        throw new Error("Path is mandatory");
    var command = "cd ".concat(repoPath, " && git log --pretty=format:\"%H,%ad,%an\"");
    return (0, execute_command_1.executeCommandNewProcessToLinesObs)("Fetch commits", 'git', ['log', '--pretty=format:%H,%ad,%an'], { cwd: repoPath }).pipe((0, rxjs_1.map)(function (commits) { return commits.split('\n'); }), (0, rxjs_1.concatMap)(function (commits) {
        return (0, rxjs_1.from)(commits);
    }), (0, rxjs_1.map)(function (commit) {
        return newCommitCompact(commit);
    }), (0, rxjs_1.filter)(function (commit) {
        return commit.date >= fromDate && commit.date <= toDate;
    }), (0, rxjs_1.catchError)(function (err) {
        console.error("Error: \"fetchCommits\" while executing command \"".concat(command, "\" - error ").concat(err.stack));
        return rxjs_1.EMPTY;
    }));
}
exports.fetchCommits = fetchCommits;
// newCommitCompact returns a new CommitCompact object with the given sha and date
function newCommitCompact(data) {
    var shaDateAuthor = data.split(',');
    var commit = {
        sha: shaDateAuthor[0],
        date: new Date(shaDateAuthor[1]),
        author: shaDateAuthor[2]
    };
    return commit;
}
exports.newCommitCompact = newCommitCompact;
// buildCommitPairArray is a function that receives an array of CommitCompact objects and returns an array of CommitPair objects
// where each CommitPair object contains two CommitCompact objects and the yearMonth of the second commit
function buildCommitPairArray(commits, repoPath) {
    var commitPairs = [];
    for (var i = 0; i < commits.length - 1; i++) {
        var commitPair = {
            repoPath: repoPath,
            yearMonth: yearMonthFromDate(commits[i + 1].date),
            commitPair: [commits[i], commits[i + 1]]
        };
        commitPairs.push(commitPair);
    }
    return commitPairs;
}
exports.buildCommitPairArray = buildCommitPairArray;
// commitsByMonth returns an instance of CommitsByMonths, where CommitCompact objects are grouped by month
// #copilot - the entire method has been generated by copilot, the only thing I changes was the key where copilot put
// month first and year second, I changed it to year first and month second
// I also changed the format of the month to be 2 digits
function newCommitsByMonth(commits) {
    var commitsByMonth = commits.reduce(function (acc, commit) {
        var key = yearMonthFromDate(commit.date);
        if (!acc[key]) {
            acc[key] = {
                commits: [],
                authors: new Set()
            };
        }
        acc[key].commits.push(commit);
        acc[key].authors.add(commit.author);
        return acc;
    }, {});
    return commitsByMonth;
}
exports.newCommitsByMonth = newCommitsByMonth;
function yearMonthFromDate(date) {
    var month = ("0" + (date.getMonth() + 1)).slice(-2);
    var year = date.getFullYear();
    return "".concat(year, "-").concat(month);
}
